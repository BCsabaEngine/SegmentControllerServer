extends ../_base

block content

  nav.navbar.navbar-expand-lg.navbar-light.bg-light.fixed-top(style=`height: ${topMargin}px`)
    .container-fluid
      .navbar-brand
        img(src='/public/favicon/favicon-32x32.png')
        | Segment
        |
        b
          = segment.name
        |
        | #
        = segment.id

      .collapse.navbar-collapse
        ul.navbar-nav.me-auto.mb-2.mb-lg-0

          li.nav-item
            a.btn.btn-secondary.active(href='/editor/layout')
              i.bi.bi-arrow-left-circle
              | 
              | Layout

          li.nav-item.ms-5
            a.nav-link(href='#' style="transform: rotate(-90deg)" onclick="setCursor()")
              i.bi.bi-cursor-fill

          li.nav-item.dropdown.dropdown-instant.ms-2
            a.nav-link.dropdown-toggleX(href='#' role='button' data-bs-toggle='dropdown')
              img(src=tracks[0].url width='24px')
              | Tracks
            ul.dropdown-menu
              each track in tracks
                li
                  a.dropdown-item(href='#' onclick=`setCursor('${track.url}', cursorCreateTrack, { type: '${track.type}'})`)
                    img(src=track.url width='16px')
                    | 
                    = track.name

        ul.navbar-nav.ms-auto.mb-2.mb-lg-0
          li#panelsave.nav-item.hidden
            a#buttonsave.btn.btn-warning(href='#' onclick='saveSegmentElements(true)' title='CTRL+S')
              | Save segment

          li.nav-item.dropdown.dropstart
            a.nav-link(href='#' role='button' data-bs-toggle='dropdown')
              i.bi.bi-gear-fill
            ul.dropdown-menu
              li
                a.dropdown-item(href='#' onclick="setBaseColor()")
                  | Base color
                  | (
                  = segment.baseColor
                  | )

          li.nav-item
            a.nav-link(href='#' onclick='toggleHelp()')
              i.bi.bi-question-circle-fill

  .card#help.hidden(style=`position: absolute; width: 28rem; top: ${topMargin + 16}px; right: 16px`, onclick='hideHelp()')
    .card-body
      h6.card-title
        i.bi.bi-keyboard
        | 
        | Shortcuts
      p.card-text
        small
          | Many functions are available with keyboard shortcuts.
        dl.row
          dt.col-sm-5
            i.bi.bi-mouse
            | 
            kbd
              | left
          dd.col-sm-7
            | Select element
            br
            | Drag element
            br
            | Resize element
            br
            | Place new element

          dt.col-sm-5
            i.bi.bi-mouse
            |
            kbd
              | right
          dd.col-sm-7
            | Element menu

          dt.col-sm-5
            | Ctrl +
            i.bi.bi-mouse
            | 
            kbd
              | left
          dd.col-sm-7
            | Select multiple element

          dt.col-sm-5
            kbd
              | Arrows
          dd.col-sm-7
            | Move selected element(s)

          dt.col-sm-5
            kbd
              | Del
          dd.col-sm-7
            | Delete selected element(s)

          dt.col-sm-5
            kbd
              | Esc
          dd.col-sm-7
            | Clear selection

          dt.col-sm-5
            kbd
              | SHIFT + 1..9
          dd.col-sm-7
            | Drawing favorite elements

          hr
          dt.col-sm-5
            | Drawing mode
          dd.col-sm-7

          dt.col-sm-5
            kbd
              | Space
          dd.col-sm-7
            | Place new element

          dt.col-sm-5
            kbd
              | Backspace
          dd.col-sm-7
            | Remove last placed element

          dt.col-sm-5
            i.bi.bi-mouse
            |
            kbd
              | right
          dd.col-sm-7
            | Exit drawing mode

          dt.col-sm-5
            kbd
              | Esc
          dd.col-sm-7
            | Exit drawing mode

          hr

          dt.col-sm-5
            kbd
              | SHIFT + S
          dd.col-sm-7
            | Save segment immediately

          dt.col-sm-5
            kbd
              | SHIFT + H
          dd.col-sm-7
            | Show/hide this help

  #elementscontainer(style='min-height: 100vh')
    .segmentelement.selectall.hidden#track(style=`position:absolute; left:0; top:0; width: ${blockSize}px; height: ${blockSize}px;`)
      img
      ul.dropdown-menu.context-menu
        li
          a.dropdown-item.text-danger(href='#' onclick='removeMyElement(this)')
            | Delete
    .segmentelement.hidden#terrain(style=`position:absolute; left:0; top:0; width: ${blockSize}px; height: ${blockSize}px)`)
      span.d-flex.align-items-center.justify-content-center(style="height:100%;").small
        |
      ul.dropdown-menu.context-menu
        li
          a.dropdown-item(href='#' onclick='callMyElementMethod(this, "inputSetColor")')
            | Set color
        li
          a.dropdown-item(href='#' onclick='callMyElementMethod(this, "inputSetText")')
            | Set text
        li
          hr.dropdown-divider
        li
          a.dropdown-item.text-danger(href='#' onclick='removeMyElement(this)')
            | Delete

  style.
    .elementselected {
      outline-width: 1px;
      outline-style: dashed;
      outline-color: `${invertBgColor}`;
    }
    .elementwarning {
      outline-width: 1px;
      outline-style: solid;
      outline-color: orange;
    }
    .elementerror {
      outline-width: 1px;
      outline-style: solid;
      outline-color: red;
    }

  script(src='/assets/interactjs/interact.min.js?' + APPVERSION)
  script(type='text/javascript').
    const topMargin = #{topMargin}
    const blockSize = #{blockSize}

    let isCtrlDown = false
    let isShiftDown = false
    $(document).on('keyup keydown', function(e){ isCtrlDown = e.ctrlKey });
    $(document).on('keyup keydown', function(e){ isShiftDown = e.shiftKey });

    let mouseMovePos = { x: 0, y: 0 }
    window.onmousemove = function(event) {
      e = event || window.event;	
      mouseMovePos = { x: Math.floor(e.clientX / blockSize), y: Math.floor((e.clientY - topMargin) / blockSize) };
    }

    interactsEnabled = true
    function enableAllInteracts(enable)
    {
      for(const element in elements)
        if (elements[element])
          elements[element].enableInteract(enable)
      interactsEnabled = enable
    }

    let elementid = 0
    const elements = {}

    let cursorCallback
    let cursorCallbackParams
    function setCursor(glyphurl, callback, params)
    {
      if (glyphurl)
      {
        enableAllInteracts(false)
        $('html').css('cursor', `url("${glyphurl}") 16 16, auto`);
      }
      else
      {
        enableAllInteracts(true)
        $('html').css('cursor', 'auto');
      }

      cursorCallback = callback
      cursorCallbackParams = params
    }
    function cursorCreateTrack(x, y, params)
    {
      new Track(x, y, params.type)
      needSaveSegmentElements()
    }
    $('#elementscontainer').on('mousedown', function(event)
    {
      switch(event.button)
      {
        case 0:
          if (cursorCallback)
            cursorCallback(mouseMovePos.x, mouseMovePos.y, cursorCallbackParams)
          break;
        case 2:
          setCursor()
          break;
      }
    })

    function removeElementById(id) { if (id in elements) elements[id].remove() }
    function removeMyElement(me) { removeElementById($(me).closest(".segmentelement").data("id")) }
    async function callMyElementMethod(me, method)
    {
      const id = $(me).closest(".segmentelement").data("id")
      if (id && (id in elements) && elements[id] && elements[id][method])
        if (await elements[id][method]())
          needSaveSegmentElements()
    }

    function getSelection() { return $('#elementscontainer').children('.elementselected') }
    function clearSelection() { getSelection().removeClass('elementselected') }
    $('#elementscontainer').on('click', (e) => { 
      const selection = getSelection()
      if (selection.length)
        if (isShiftDown)
        {
          e.preventDefault()
          const frompos = { x: Number.POSITIVE_INFINITY, y: Number.POSITIVE_INFINITY }
          for(const selected of getSelection())
          {
            const jselected = $(selected)[0]
            console.log(jselected.offsetLeft, jselected.offsetTop - topMargin)
            if (frompos.x > jselected.offsetLeft)
              frompos.x = jselected.offsetLeft
            if (frompos.y > jselected.offsetTop - topMargin)
              frompos.y = jselected.offsetTop - topMargin
          }
          frompos.x = Math.floor(frompos.x / blockSize)
          frompos.y = Math.floor(frompos.y / blockSize)

          const topos = mouseMovePos
          if (frompos.x > topos.x)
          {
            let x = frompos.x
            frompos.x = topos.x
            topos.x = x
          }
          if (frompos.y > topos.y)
          {
            let y = frompos.y
            frompos.y = topos.y
            topos.y = y
          }

          for(const element of $('#elementscontainer').children())
          {
            const jelement = $(element)[0]
            console.log(jelement)
            const jx = jelement.offsetLeft
            const jy = jelement.offsetTop - topMargin

            if (jx >= frompos.x * blockSize && jx <= topos.x * blockSize)
              if (jy >= frompos.y * blockSize && jy <= topos.y * blockSize)
              {
                console.log(jelement)
                //jelement.addClass('elementselected')
              }
          }

          console.log(frompos, topos)
        }
        else
        {
          e.preventDefault()
          clearSelection()
        }
    })

    $('html').on('contextmenu', function () {
      $('.context-menu').hide();
      return false
    })
    initContextMenus('.segmentelement')

    lastElements = []
    function addElementToUndoQueue(element)
    {
      lastElements.push(element)
      while (lastElements.length > 10) lastElements.shift()
    }

    window.addEventListener("keydown", function (event) {
      if (event.defaultPrevented) return

      if (event.keyCode == 32)
      {
        if (cursorCallback)
          cursorCallback(mouseMovePos.x, mouseMovePos.y, cursorCallbackParams)
        event.preventDefault()
        return
      }

      if (event.key == "Backspace")
      {
        if (lastElements.length && cursorCallback)
        {
          const last = lastElements.pop()
          if (last)
            last.remove()
          event.preventDefault()
        }
      }

      if (event.key == "Esc" || event.key == "Escape")
      {
        clearSelection()
        setCursor()
        event.preventDefault()
      }

      const selections =  getSelection()
      if (selections.length == 0) return 
      const ids = []
      for(const selection of selections)
        ids.push($(selection).data('id'))

      switch (event.key) {
        case "Down": 
        case "ArrowDown":
          for(const id of ids)
            elements[id].moveDown()
          break;
        case "Up": 
        case "ArrowUp":
          let allowup = true
          for(const id of ids)
            if (!elements[id].canMoveUp())
            {
              allowup = false 
              break
            }
          if (allowup)
            for(const id of ids)
              elements[id].moveUp()
          break;
        case "Left": 
        case "ArrowLeft":
          let allowleft = true
          for(const id of ids)
            if (!elements[id].canMoveLeft())
            {
              allowleft = false 
              break
            }
          if (allowleft)
            for(const id of ids)
              elements[id].moveLeft()
          break;
        case "Right": 
        case "ArrowRight":
          for(const id of ids)
            elements[id].moveRight()
          break;
        case "Delete":
          for(const selection of selections)
          {
            const deleteId = $(selection).data('id')
            if (deleteId in elements && elements[deleteId])
              elements[deleteId].remove()
          }
          break;
        default:
          return;
      }
      event.preventDefault();
    }, true);

    class Track {
      id
      x
      y
      type = null
      constructor(x, y, type)
      {
        elementid++
        this.id = elementid
        elements[this.id] = this
        addElementToUndoQueue(this)
        this.x = x
        this.y = y

        const jelement = $("#track")
          .clone()
          .attr('id', 'element' + this.id)
          .data('id', this.id)
          .css('left', x * blockSize)
          .css('top', y * blockSize + topMargin)
          .css('z-index', 1)
          .insertAfter("#track")
          .removeClass('hidden')

        this.setType(type)

        const that = this

        jelement.on('click', () => {
          if (!isCtrlDown) clearSelection()
          jelement.toggleClass('elementselected')
          return false
        })

        const delta = { x: 0, y: 0 }
        interact(document.getElementById('element' + this.id))
          .draggable({
            listeners: {
              start (event) {
                delta.x = 0
                delta.y = 0
                stopAutosaveTimer()
                if (!isCtrlDown) clearSelection()
                jelement.addClass('elementselected')
              },
              move (event) {
                delta.x += event.dx
                delta.y += event.dy
                event.target.style.left = `${that.x * blockSize + delta.x}px`
                event.target.style.top = `${that.y * blockSize + topMargin + delta.y}px`
              },
              end (event) {
                that.setPos(jelement.offset().left / blockSize, (jelement.offset().top - topMargin) / blockSize)
                needSaveSegmentElements()
              }
            },
            modifiers: [
              interact.modifiers.snap({
                targets: [
                  interact.snappers.grid({ x: blockSize, y: blockSize })
                ],
                relativePoints: [ { x: 0, y: 0 } ]
              }),
              interact.modifiers.restrictRect({
                restriction: { x: 0, y: topMargin, width: 10000, height: 10000 },
                endOnly: false
              })
            ]
          })
          .draggable(interactsEnabled)
      }

      enableInteract(enable) { interact(document.getElementById('element' + this.id)).draggable(enable) }

      element() { return $(`#element${this.id}`) }

      setType(type)
      {
        this.type = type
        this.element()
          .find('img')
          .attr('src', `/glyph/track/${this.type}`)
      }

      containsPoint(x, y) { return this.x == x && this.y == y }

      canMoveLeft() { return this.x > 0 }
      canMoveUp() { return this.y > 0 }

      moveLeft() { this.setPos(this.x - 1, this.y) }
      moveRight() { this.setPos(this.x + 1, this.y) }
      moveUp() { this.setPos(this.x, this.y - 1) }
      moveDown() { this.setPos(this.x, this.y +1 ) }

      setPos(x, y)
      {
        if (x < 0 || y < 0) return
        this.x = x
        this.y = y

        this.element()
          .css('left', this.x * blockSize)
          .css('top', this.y * blockSize + topMargin)

        //- for(const id in elements)
        //-   if (id != this.id)
        //-     if (elements[id] instanceof Track)
        //-       if (elements[id].containsPoint(this.x, this.y))
        //-         elements[id].remove()
        needSaveSegmentElements()
      }

      remove()
      {
        if (this.id in elements)
          delete elements[this.id]
        this.element().remove()
        needSaveSegmentElements()
      }

      saveData() { return { class: 'track', x: this.x, y: this.y, type: this.type } }
    }

    class Terrain {
      id
      x
      y
      w
      h
      color
      text
      constructor(x, y, w, h, color, text)
      {
        elementid++
        this.id = elementid
        elements[this.id] = this
        addElementToUndoQueue(this)
        this.x = x
        this.y = y
        this.w = w
        this.h = h

        const jelement = $("#terrain")
          .clone()
          .attr('id', 'element' + this.id)
          .data('id', this.id)
          .css('left', x * blockSize)
          .css('top', y * blockSize + topMargin)
          .css('width', w * blockSize)
          .css('height', h * blockSize)
          .css('z-index', 0)
          .insertAfter("#terrain")
          .removeClass('hidden')

        this.setColor(color)
        this.setText(text)

        const that = this

        jelement.on('click', () => {
          if (!isCtrlDown) clearSelection()
          jelement.toggleClass('elementselected')
          return false
        })

        const moveDelta = { x: 0, y: 0 }
        const sizeDelta = { x: 0, y: 0 }
        interact(document.getElementById('element' + this.id))
          .draggable({
            listeners: {
              start (event) {
                moveDelta.x = 0
                moveDelta.y = 0
                stopAutosaveTimer()
                if (!isCtrlDown) clearSelection()
                jelement.addClass('elementselected')
              },
              move (event) {
                moveDelta.x += event.dx
                moveDelta.y += event.dy
                event.target.style.left = `${that.x * blockSize + moveDelta.x}px`
                event.target.style.top = `${that.y * blockSize + topMargin + moveDelta.y}px`
              },
              end (event) {
                that.setPos(jelement.offset().left / blockSize, (jelement.offset().top - topMargin) / blockSize)
                needSaveSegmentElements()
              },
            },
            modifiers: [
              interact.modifiers.snap({
                targets: [
                  interact.snappers.grid({ x: blockSize, y: blockSize })
                ],
                relativePoints: [ { x: 0, y: 0 } ]
              }),
              interact.modifiers.restrictRect({
                restriction: { x: 0, y: topMargin, width: 10000, height: 10000 },
                endOnly: false
              })
            ]
          })
          .draggable(interactsEnabled)
          .resizable({
            edges: { left: true, right: true, bottom: true, top: true },
            listeners: {
              start(event) {
                sizeDelta.x = 0
                sizeDelta.y = 0
                stopAutosaveTimer()
              },
              move (event) {
                sizeDelta.x += event.deltaRect.left
                sizeDelta.y += event.deltaRect.top

                event.target.style.width = `${event.rect.width}px`
                event.target.style.height = `${event.rect.height}px`


                event.target.style.left = `${that.x * blockSize + sizeDelta.x}px`
                event.target.style.top = `${that.y * blockSize + topMargin + sizeDelta.y}px`

                //event.target.textContent = Math.round(event.rect.width / blockSize) + '\u00D7' + Math.round(event.rect.height / blockSize)
              },
              end (event) {
                that.setPos(jelement.offset().left / blockSize, (jelement.offset().top - topMargin) / blockSize)
                that.setSize(jelement.width() / blockSize, jelement.height() / blockSize)
                //event.target.textContent = ''
                needSaveSegmentElements()
              }
            },
            modifiers: [
              interact.modifiers.snap({
                targets: [
                  interact.snappers.grid({ x: blockSize, y: blockSize })
                ],
                relativePoints: [ { x: 0, y: 0 } ]
              }),
              interact.modifiers.restrictEdges({ outer: 'parent' }),
              interact.modifiers.restrictSize({ min: { width: blockSize, height: blockSize } })
            ],
            inertia: true
          })
          .resizable(interactsEnabled)

      }

      enableInteract(enable) { interact(document.getElementById('element' + this.id)).draggable(enable).resizable(enable) }

      element() { return $(`#element${this.id}`) }

      setColor(color)
      {
        this.color = color
        this.element()
          .css('background-color', this.color)
      }

      setText(text)
      {
        this.text = text
        this.element()
          .find('span')
          .text(text)
      }

      containsPoint(x, y) { return this.x >= x && this.x + this.w <= x && this.y >= y && this.y + this.h <= y}

      canMoveLeft() { return this.x > 0 }
      canMoveUp() { return this.y > 0 }

      moveLeft() { this.setPos(this.x - 1, this.y) }
      moveRight() { this.setPos(this.x + 1, this.y) }
      moveUp() { this.setPos(this.x, this.y - 1) }
      moveDown() { this.setPos(this.x, this.y +1 ) }

      setPos(x, y)
      {
        if (x < 0 || y < 0) return
        this.x = x
        this.y = y

        this.element()
          .css('left', this.x * blockSize)
          .css('top', this.y * blockSize + topMargin)
        needSaveSegmentElements()
      }

      setSize(w, h)
      {
        if (w <= 0 || h <= 0) return
        this.w = w
        this.h = h

        this.element()
          .css('width', this.w * blockSize)
          .css('height', this.h * blockSize)
        needSaveSegmentElements()
      }

      remove()
      {
        if (this.id in elements)
          delete elements[this.id]
        this.element().remove()
        needSaveSegmentElements()
      }

      saveData() { return { class: 'terrain', x: this.x, y: this.y, w: this.w, h: this.h, color: this.color, text: this.text } }

      async inputSetColor()
      {
        const { value: newColor } = await Swal.fire({
          title: 'Color of terrain',
          showCancelButton: true,
          backdrop: false,
          preConfirm: () => { return document.getElementById('html5colorpicker').value },
          html: '<input type="color" id="html5colorpicker" value="' + this.color + '" style="width:50%">' 
        })

        if (newColor)
        {
          this.setColor(newColor)
          return true
        }
      }

      async inputSetText()
      {
        const { value: newTitle } = await Swal.fire({
          title: 'Title of terrain',
          input: 'text',
          inputValue: this.text || '',
          showCancelButton: true,
        })

        if (newTitle !== undefined)
        {
          this.setText(newTitle)
          return true
        }
      }
    }

  script(type='text/javascript')
    | $(function() {
    | 
    each terrain in segment.terrains
      |  new Terrain(
      = terrain.x
      |, 
      = terrain.y
      |, 
      = terrain.width
      |, 
      = terrain.height
      |, '
      = terrain.color
      |'
      |, '
      = terrain.text
      |');
      |
    |
    each track in segment.tracks
      |  new Track(
      = track.x
      |, 
      = track.y
      |, '
      = track.type
      |');
      |
    |
    | detectErrors()
    |
    | })

  script(type='text/javascript').
    hotkeys('shift+s', function(event)
    {
      event.preventDefault()
      saveSegmentElements(true)
    });
    hotkeys('shift+h', function(event){ toggleHelp() })
    function showHelp()
    {
      $("#help").fadeIn()
      setTimeout(() => $("#help").fadeOut(), 30 * 1000)
      localStorage.setItem('hideSegmentHelp', false)
    }
    function hideHelp()
    {
      $("#help").fadeOut()
      localStorage.setItem('hideSegmentHelp', true)
    }
    function toggleHelp()
    {
      if($("#help").is(":visible"))
        hideHelp()
      else
        showHelp()
    }
    if (localStorage.getItem('hideSegmentHelp') != 'true') showHelp()

    const segments = []

    let timerAutosave = null
    let downcountSuccessSave = 1
    function stopAutosaveTimer() { clearTimeout(timerAutosave) }
    function startAutosaveTimer()
    {
      stopAutosaveTimer()
      timerAutosave = setTimeout(() => { saveSegmentElements() }, 750)
    }
    function detectErrors()
    {
      $('#elementscontainer').children('.elementerror').removeClass('elementerror')
      for(const a in elements)
        if (elements[a] instanceof Track)
          for(const b in elements)
            if (a != b && elements[b] instanceof Track)
              if (elements[a].containsPoint(elements[b].x, elements[b].y))
                elements[a].element().addClass('elementerror')
    }
    function needSaveSegmentElements()
    {
      $('#panelsave').fadeIn()
      startAutosaveTimer()
      detectErrors()
    }
    function saveSegmentElements(displaytoast)
    {
      stopAutosaveTimer()

      if(!$("#panelsave").is(":visible")) return

      const elementsDataToSave = {}
      for(const id in elements)
        elementsDataToSave[id] = elements[id].saveData()
      $.post('/editor/segment/#{segment.id}/set/elements', { elements: JSON.stringify(elementsDataToSave) })
        .done(function() { 
          if (displaytoast && downcountSuccessSave)
          {
            ToastSuccess.fire({ html: 'Saved successfully<br/><small>(Will not appear next time)</small>' })
            downcountSuccessSave--
          }
          $('#buttonsave').removeClass('btn-danger').addClass('btn-warning')
          $('#panelsave').fadeOut()
        })
        .fail(function(xhr, status, error) {
          if (displaytoast)
            ToastError.fire({ html: `<b>Error</b><br/>${xhr.responseText}` })
          else
            $('#buttonsave').removeClass('btn-warning').addClass('btn-danger')
          downcountSuccessSave = 1
        })
    }

    async function setBaseColor()
    {
      const { value: baseColor } = await Swal.fire({
        title: 'Color of plate (background)',
        showCancelButton: true,
        preConfirm: () => { return document.getElementById('html5colorpicker').value },
        html: '<input type="color" id="html5colorpicker" value="#{segment.baseColor}" style="width:50%">' 
      })

      if (baseColor)
        $.post('/editor/segment/#{segment.id}/set/baseColor', { baseColor: baseColor })
          .done(function() { 
            pagereload()
          })
          .fail(function(xhr, status, error) {
            ToastError.fire({ html: `<b>Error</b><br/>${xhr.responseText}` })
          })
    }
