extends ../_base

block content

  nav.navbar.navbar-expand-lg.navbar-light.bg-light(style=`height: ${topMargin}px`)
    .container-fluid
      .navbar-brand
        img(src='/public/favicon/favicon-32x32.png')
        | Segment
        |
        b
          = segment.name
        |
        | #
        = segment.id

      .collapse.navbar-collapse
        ul.navbar-nav.me-auto.mb-2.mb-lg-0

          li.nav-item
            a.btn.btn-secondary.active(href='/editor/layout')
              i.bi.bi-arrow-left-circle
              | 
              | Layout

          li.nav-item.ms-5
            a.nav-link(href='#' style="transform: rotate(-90deg)")
              i.bi.bi-cursor-fill

          li.nav-item.dropdown.dropdown-instant.ms-2
            a.nav-link.dropdown-toggleX(href='#' role='button' data-bs-toggle='dropdown')
              img(src=tracks[0].url width='24px')
              | Tracks
            ul.dropdown-menu
              each track in tracks
                li
                  a.dropdown-item(href='#')
                    img(src=track.url width='16px')
                    | 
                    = track.name

        ul.navbar-nav.ms-auto.mb-2.mb-lg-0
          li#panelsave.nav-item.hidden
            a#buttonsave.btn.btn-warning(href='#' onclick='saveSegmentElements(true)' title='CTRL+S')
              | Save segment

          li.nav-item.dropdown.dropstart
            a.nav-link(href='#' role='button' data-bs-toggle='dropdown')
              i.bi.bi-gear-fill
            ul.dropdown-menu
              li
                a.dropdown-item(href='#' onclick="setBaseColor()")
                  | Base color
                  | (
                  = segment.baseColor
                  | )

          li.nav-item
            a.nav-link(href='#' onclick='toggleHelp()')
              i.bi.bi-question-circle-fill

  .card#help.hidden(style=`position: absolute; width: 24rem; top: ${topMargin + 16}px; right: 16px`, onclick='hideHelp()')
    .card-body
      h6.card-title
        i.bi.bi-keyboard
        | 
        | Shortcuts
      p.card-text
        small
          | Many commands are available with keyboard shortcuts.
        dl.row
          dt.col-sm-5
            kbd
              | SHIFT + N
          dd.col-sm-7
            | New segment

          dt.col-sm-5
            kbd
              | SHIFT + S
          dd.col-sm-7
            | Save layout immediately

          dt.col-sm-5
            kbd
              | SHIFT + 1..9
          dd.col-sm-7
            | Open segment
            small
              |
              | (1-9 only)

          dt.col-sm-5
            kbd
              | SHIFT + H
          dd.col-sm-7
            | Show/hide this help

  #elementscontainer(style='min-height: 100vh')
    .segmentelement.hidden#track(style=`position:absolute; left:0; top:0; width: ${blockSize}px; height: ${blockSize}px)`)
      img
      ul.dropdown-menu.context-menu
        li
          a.dropdown-item.text-danger(href='#' onclick='removeMyElement(this)')
            | Delete
    .segmentelement.hidden#terrain(style=`position:absolute; left:0; top:0; width: ${blockSize}px; height: ${blockSize}px)`)
      ul.dropdown-menu.context-menu
        li
          a.dropdown-item(href='#')
            | Rename
        li
          a.dropdown-item(href='#')
            | Modify ID
            | (#
            | )
        li
          a.dropdown-item.text-danger(href='#' onclick='removeMyElement(this)')
            | Delete

  style.
    .elementselected {
      outline-width: 1px;
      outline-style: dashed;
      outline-color: `${invertBgColor}`;
    }

  script(src='/assets/interactjs/interact.min.js?' + APPVERSION)
  script(type='text/javascript').
    const topMargin = #{topMargin}
    const blockSize = #{blockSize}

    let isShiftDown = false
    $(document).on('keyup keydown', function(e){ isShiftDown = e.shiftKey });

    let elementid = 0
    const elements = {}

    function removeElementById(id) { if (id in elements) elements[id].remove() }
    function removeMyElement(me) { removeElementById($(me).closest(".segmentelement").data("id")) }

    function clearSelection() { $('#elementscontainer').children().removeClass('elementselected') }

    window.addEventListener("keydown", function (event) {
      if (event.defaultPrevented) return

      const selections = $('#elementscontainer').children('.elementselected')
      if (selections.length == 0) return 

      const ids = []
      for(const selection of selections)
        ids.push($(selection).data('id'))

      switch (event.key) {
        case "Down": 
        case "ArrowDown":
          for(const id of ids)
            elements[id].moveDown()
          break;
        case "Up": 
        case "ArrowUp":
          let allowup = true
          for(const id of ids)
            if (!elements[id].canMoveUp())
            {
              allowup = false 
              break
            }
          if (allowup)
            for(const id of ids)
              elements[id].moveUp()
          break;
        case "Left": 
        case "ArrowLeft":
          let allowleft = true
          for(const id of ids)
            if (!elements[id].canMoveLeft())
            {
              allowleft = false 
              break
            }
          if (allowleft)
            for(const id of ids)
              elements[id].moveLeft()
          break;
        case "Right": 
        case "ArrowRight":
          for(const id of ids)
            elements[id].moveRight()
          break;
        case "Esc":
        case "Escape":
          clearSelection()
          break;
        default:
          return;
      }
      event.preventDefault();
    }, true);

    class Track {
      id
      x
      y
      type = null
      constructor(x, y, type)
      {
        elementid++
        this.id = elementid
        elements[this.id] = this
        this.x = x
        this.y = y

        const jelement = $("#track")
          .clone()
          .attr('id', 'element' + this.id)
          .data('id', this.id)
          .css('left', x * blockSize)
          .css('top', y * blockSize + topMargin)
          .css('z-index', 1)
          .insertAfter("#track")
          .removeClass('hidden')

        this.setType(type)

        const that = this

        jelement.on('click', () => {
          if (!isShiftDown) clearSelection()
          jelement.toggleClass('elementselected')
          return false
        })

        const delta = { x: 0, y: 0 }
        interact(document.getElementById('element' + this.id))
          .draggable({
            listeners: {
              start (event) {
                delta.x = 0
                delta.y = 0
                stopAutosaveTimer()
                if (!isShiftDown) clearSelection()
                jelement.addClass('elementselected')
              },
              move (event) {
                delta.x += event.dx
                delta.y += event.dy
                event.target.style.left = `${that.x * blockSize + delta.x}px`
                event.target.style.top = `${that.y * blockSize + topMargin + delta.y}px`
              },
              end (event) {
                that.setPos(jelement.offset().left / blockSize, (jelement.offset().top - topMargin) / blockSize)
                $('#panelsave').fadeIn()
                startAutosaveTimer()
              },
            },
            modifiers: [
              interact.modifiers.snap({
                targets: [
                  interact.snappers.grid({ x: blockSize, y: blockSize })
                ],
                relativePoints: [ { x: 0, y: 0 } ]
              }),
              interact.modifiers.restrictRect({
                restriction: { x: 0, y: topMargin, width: 10000, height: 10000 },
                endOnly: false
              })
            ]
          })
      }

      element() { return $(`#element${this.id}`) }

      setType(type)
      {
        this.type = type
        this.element()
          .find('img')
          .attr('src', `/glyph/track/${this.type}`)
      }

      containsPoint(x, y) { return this.x == x && this.y == y }

      canMoveLeft() { return this.x > 0 }
      canMoveUp() { return this.y > 0 }

      moveLeft() { this.setPos(this.x - 1, this.y) }
      moveRight() { this.setPos(this.x + 1, this.y) }
      moveUp() { this.setPos(this.x, this.y - 1) }
      moveDown() { this.setPos(this.x, this.y +1 ) }

      setPos(x, y)
      {
        if (x < 0 || y < 0) return
        this.x = x
        this.y = y

        this.element()
          .css('left', this.x * blockSize)
          .css('top', this.y * blockSize + topMargin)

        //- for(const id in elements)
        //-   if (id != this.id)
        //-     if (elements[id] instanceof Track)
        //-       if (elements[id].containsPoint(this.x, this.y))
        //-         elements[id].remove()
      }

      remove()
      {
        if (this.id in elements)
          delete elements[this.id]
        this.element().remove()
      }
    }

    class Terrain {
      id
      x
      y
      w
      h
      color
      constructor(x, y, w, h, color)
      {
        elementid++
        this.id = elementid
        elements[this.id] = this
        this.x = x
        this.y = y
        this.w = w
        this.h = h

        const jelement = $("#terrain")
          .clone()
          .attr('id', 'element' + this.id)
          .data('id', this.id)
          .css('left', x * blockSize)
          .css('top', y * blockSize + topMargin)
          .css('width', w * blockSize)
          .css('height', h * blockSize)
          .css('z-index', 0)
          .insertAfter("#terrain")
          .removeClass('hidden')

        this.setColor(color)

        const that = this

        jelement.on('click', () => {
          if (!isShiftDown) clearSelection()
          jelement.toggleClass('elementselected')
          return false
        })

        const moveDelta = { x: 0, y: 0 }
        const sizeDelta = { x: 0, y: 0 }
        interact(document.getElementById('element' + this.id))
          .draggable({
            listeners: {
              start (event) {
                moveDelta.x = 0
                moveDelta.y = 0
                stopAutosaveTimer()
                if (!isShiftDown) clearSelection()
                jelement.addClass('elementselected')
              },
              move (event) {
                moveDelta.x += event.dx
                moveDelta.y += event.dy
                event.target.style.left = `${that.x * blockSize + moveDelta.x}px`
                event.target.style.top = `${that.y * blockSize + topMargin + moveDelta.y}px`
              },
              end (event) {
                that.setPos(jelement.offset().left / blockSize, (jelement.offset().top - topMargin) / blockSize)
                $('#panelsave').fadeIn()
                startAutosaveTimer()
              },
            },
            modifiers: [
              interact.modifiers.snap({
                targets: [
                  interact.snappers.grid({ x: blockSize, y: blockSize })
                ],
                relativePoints: [ { x: 0, y: 0 } ]
              }),
              interact.modifiers.restrictRect({
                restriction: { x: 0, y: topMargin, width: 10000, height: 10000 },
                endOnly: false
              })
            ]
          })
          .resizable({
            edges: { left: true, right: true, bottom: true, top: true },
            listeners: {
              start(event) {
                sizeDelta.x = 0
                sizeDelta.y = 0
                stopAutosaveTimer()
              },
              move (event) {
                sizeDelta.x += event.deltaRect.left
                sizeDelta.y += event.deltaRect.top
                console.log('move', sizeDelta)

                event.target.style.width = `${event.rect.width}px`
                event.target.style.height = `${event.rect.height}px`


                event.target.style.left = `${that.x * blockSize + sizeDelta.x}px`
                event.target.style.top = `${that.y * blockSize + topMargin + sizeDelta.y}px`

                event.target.textContent = Math.round(event.rect.width / blockSize) + '\u00D7' + Math.round(event.rect.height / blockSize)
              },
              end (event) {
                that.setPos(jelement.offset().left / blockSize, (jelement.offset().top - topMargin) / blockSize)
                that.setSize(jelement.width() / blockSize, jelement.height() / blockSize)
                event.target.textContent = ''
                $('#panelsave').fadeIn()
                startAutosaveTimer()
              }
            },
            modifiers: [
              interact.modifiers.snap({
                targets: [
                  interact.snappers.grid({ x: blockSize, y: blockSize })
                ],
                relativePoints: [ { x: 0, y: 0 } ]
              }),
              interact.modifiers.restrictEdges({ outer: 'parent' }),
              interact.modifiers.restrictSize({ min: { width: blockSize, height: blockSize } })
            ],
            inertia: true
          })

      }

      element() { return $(`#element${this.id}`) }

      setColor(color)
      {
        this.color = color
        this.element()
          .css('background-color', this.color)
      }

      containsPoint(x, y) { return this.x >= x && this.x + this.w <= x && this.y >= y && this.y + this.h <= y}

      canMoveLeft() { return this.x > 0 }
      canMoveUp() { return this.y > 0 }

      moveLeft() { this.setPos(this.x - 1, this.y) }
      moveRight() { this.setPos(this.x + 1, this.y) }
      moveUp() { this.setPos(this.x, this.y - 1) }
      moveDown() { this.setPos(this.x, this.y +1 ) }

      setPos(x, y)
      {
        if (x < 0 || y < 0) return
        this.x = x
        this.y = y

        this.element()
          .css('left', this.x * blockSize)
          .css('top', this.y * blockSize + topMargin)
      }

      setSize(w, h)
      {
        if (w <= 0 || h <= 0) return
        this.w = w
        this.h = h

        this.element()
          .css('width', this.w * blockSize)
          .css('height', this.h * blockSize)
      }

      remove()
      {
        if (this.id in elements)
          delete elements[this.id]
        this.element().remove()
      }
    }

    $(function() {
      //$('html').css('cursor', 'url("/glyph/track/vline"), auto');      

      new Terrain(0, 0, 15, 10, '#ebc417')

      new Track(0, 0, 'hline')
      new Track(1, 0, 'hline')
      new Track(2, 0, 'hline')
      new Track(3, 0, 'hline')
      new Track(4, 0, 'hline')
      new Track(5, 0, 'trturn')
      new Track(4, 4, 'vline')

      initContextMenus('.segmentelement')

      $('#elementscontainer').on('click', () => { clearSelection() })
    })

    hotkeys('ctrl+s, command+s', function(event)
    {
      event.preventDefault()
      saveSegmentElements(true)
    });
    hotkeys('shift+h', function(event){ toggleHelp() })
    function showHelp()
    {
      $("#help").fadeIn()
      setTimeout(() => $("#help").fadeOut(), 30 * 1000)
      localStorage.setItem('hideSegmentHelp', false)
    }
    function hideHelp()
    {
      $("#help").fadeOut()
      localStorage.setItem('hideSegmentHelp', true)
    }
    function toggleHelp()
    {
      if($("#help").is(":visible"))
        hideHelp()
      else
        showHelp()
    }
    if (localStorage.getItem('hideSegmentHelp') != 'true') showHelp()

    const segments = []

    let timerAutosave = null
    let downcountSuccessSave = 1
    function stopAutosaveTimer() { clearTimeout(timerAutosave) }
    function startAutosaveTimer()
    {
      stopAutosaveTimer()
      timerAutosave = setTimeout(() => { saveSegmentElements() }, 3000)
    }
    function saveSegmentElements(displaytoast)
    {
      stopAutosaveTimer()

      if(!$("#panelsave").is(":visible")) return

      //- const locations = {}
      //- for(const segment of segments)
      //- {
      //-   const id = segment.id
      //-   const x = segment.jelement.offset().left / blockSize
      //-   const y = (segment.jelement.offset().top - topMargin) / blockSize
      //-   locations[id] = {x, y}
      //- }
      //- $.post('/editor/layout/set/segmentlocations', { locations: JSON.stringify(locations) })
      //-   .done(function() { 
      //-     if (displaytoast && downcountSuccessSave)
      //-     {
      //-       ToastSuccess.fire({ html: 'Saved successfully<br/><small>(Will not appear next time)</small>' })
      //-       downcountSuccessSave--
      //-     }
      //-     $('#buttonsave').removeClass('btn-danger').addClass('btn-warning')
      //-     $('#panelsave').hide()
      //-   })
      //-   .fail(function(xhr, status, error) {
      //-     if (displaytoast)
      //-       ToastError.fire({ html: `<b>Error</b><br/>${xhr.responseText}` })
      //-     else
      //-       $('#buttonsave').removeClass('btn-warning').addClass('btn-danger')
      //-     downcountSuccessSave = 1
      //-   })
    }

    async function setBaseColor()
    {
      const { value: baseColor } = await Swal.fire({
        title: 'Color of plate (background)',
        showCancelButton: true,
        preConfirm: () => { return document.getElementById('html5colorpicker').value },
        html: '<input type="color" id="html5colorpicker" value="#{segment.baseColor}" style="width:50%">' 
    })

    if (baseColor)
      $.post('/editor/segment/#{segment.id}/set/baseColor', { baseColor: baseColor })
        .done(function() { 
          pagereload()
        })
        .fail(function(xhr, status, error) {
          ToastError.fire({ html: `<b>Error</b><br/>${xhr.responseText}` })
        })
    }
